{
  "version": 3,
  "sources": ["../../../../node_modules/eventemitter3/index.js", "../../src/provider/provider.ts", "../../src/provider/no-op-provider.ts", "../../src/provider/in-memory-provider/in-memory-provider.ts", "../../src/events/open-feature-event-emitter.ts", "../../../../node_modules/eventemitter3/index.mjs", "../../src/events/events.ts", "../../src/provider/in-memory-provider/variant-not-found-error.ts", "../../src/open-feature.ts", "../../src/client/internal/open-feature-client.ts", "../../src/index.ts"],
  "sourcesContent": ["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "import type {\n  CommonProvider,\n  EvaluationContext,\n  JsonValue,\n  Logger,\n  ResolutionDetails,\n} from '@openfeature/core';\nimport { ClientProviderStatus } from '@openfeature/core';\nimport type { Hook } from '../hooks';\n\nexport { ClientProviderStatus as ProviderStatus };\n\n/**\n * Interface that providers must implement to resolve flag values for their particular\n * backend or vendor.\n *\n * Implementation for resolving all the required flag types must be defined.\n */\nexport interface Provider extends CommonProvider<ClientProviderStatus> {\n  /**\n   * A provider hook exposes a mechanism for provider authors to register hooks\n   * to tap into various stages of the flag evaluation lifecycle. These hooks can\n   * be used to perform side effects and mutate the context for purposes of the\n   * provider. Provider hooks are not configured or controlled by the application author.\n   */\n  readonly hooks?: Hook[];\n\n  /**\n   * A handler function to reconcile changes made to the static context.\n   * Called by the SDK when the context is changed.\n   *\n   * Returning a promise will put the provider in the RECONCILING state and\n   * emit the ProviderEvents.Reconciling event.\n   *\n   * Return void will avoid putting the provider in the RECONCILING state and\n   * **not** emit the ProviderEvents.Reconciling event.\n   * @param oldContext\n   * @param newContext\n   */\n  onContextChange?(oldContext: EvaluationContext, newContext: EvaluationContext): Promise<void> | void;\n\n  /**\n   * Resolve a boolean flag and its evaluation details.\n   */\n  resolveBooleanEvaluation(\n    flagKey: string,\n    defaultValue: boolean,\n    context: EvaluationContext,\n    logger: Logger,\n  ): ResolutionDetails<boolean>;\n\n  /**\n   * Resolve a string flag and its evaluation details.\n   */\n  resolveStringEvaluation(\n    flagKey: string,\n    defaultValue: string,\n    context: EvaluationContext,\n    logger: Logger,\n  ): ResolutionDetails<string>;\n\n  /**\n   * Resolve a numeric flag and its evaluation details.\n   */\n  resolveNumberEvaluation(\n    flagKey: string,\n    defaultValue: number,\n    context: EvaluationContext,\n    logger: Logger,\n  ): ResolutionDetails<number>;\n\n  /**\n   * Resolve and parse an object flag and its evaluation details.\n   */\n  resolveObjectEvaluation<T extends JsonValue>(\n    flagKey: string,\n    defaultValue: T,\n    context: EvaluationContext,\n    logger: Logger,\n  ): ResolutionDetails<T>;\n}\n", "import type { JsonValue, ResolutionDetails } from '@openfeature/core';\nimport type { Provider } from './provider';\n\nconst REASON_NO_OP = 'No-op';\n\n/**\n * The No-op provider is set by default, and simply always returns the default value.\n */\nclass NoopFeatureProvider implements Provider {\n  readonly metadata = {\n    name: 'No-op Provider',\n  } as const;\n\n  resolveBooleanEvaluation(_: string, defaultValue: boolean): ResolutionDetails<boolean> {\n    return this.noOp(defaultValue);\n  }\n\n  resolveStringEvaluation(_: string, defaultValue: string): ResolutionDetails<string> {\n    return this.noOp(defaultValue);\n  }\n\n  resolveNumberEvaluation(_: string, defaultValue: number): ResolutionDetails<number> {\n    return this.noOp(defaultValue);\n  }\n\n  resolveObjectEvaluation<T extends JsonValue>(_: string, defaultValue: T): ResolutionDetails<T> {\n    return this.noOp<T>(defaultValue);\n  }\n\n  private noOp<T>(defaultValue: T) {\n    return {\n      value: defaultValue,\n      reason: REASON_NO_OP,\n    };\n  }\n}\n\nexport const NOOP_PROVIDER = new NoopFeatureProvider();\n", "import type {\n  EvaluationContext,\n  FlagValueType,\n  JsonValue,\n  Logger,\n  ResolutionDetails} from '@openfeature/core';\nimport {\n  FlagNotFoundError,\n  GeneralError,\n  OpenFeatureError,\n  StandardResolutionReasons,\n  TypeMismatchError,\n} from '@openfeature/core';\nimport type { Provider } from '../provider';\nimport { OpenFeatureEventEmitter, ProviderEvents } from '../../events';\nimport type { FlagConfiguration, Flag } from './flag-configuration';\nimport { VariantNotFoundError } from './variant-not-found-error';\n\n/**\n * A simple OpenFeature provider intended for demos and as a test stub.\n */\nexport class InMemoryProvider implements Provider {\n  public readonly events = new OpenFeatureEventEmitter();\n  public readonly runsOn = 'client';\n  readonly metadata = {\n    name: 'in-memory',\n  } as const;\n  private _flagConfiguration: FlagConfiguration;\n  private _context: EvaluationContext | undefined;\n\n  constructor(flagConfiguration: FlagConfiguration = {}) {\n    this._flagConfiguration = { ...flagConfiguration };\n  }\n\n  /**\n   * Overwrites the configured flags.\n   * @param { FlagConfiguration } flagConfiguration new flag configuration\n   */\n  async putConfiguration(flagConfiguration: FlagConfiguration) {\n    try {\n      const flagsChanged = Object.entries({...flagConfiguration, ...this._flagConfiguration})\n        .map(([key]) => key);\n\n      this._flagConfiguration = { ...flagConfiguration };\n      this.events.emit(ProviderEvents.ConfigurationChanged, { flagsChanged });\n    } catch (err) {\n      this.events.emit(ProviderEvents.Error);\n      throw err;\n    }\n  }\n\n  resolveBooleanEvaluation(\n    flagKey: string,\n    defaultValue: boolean,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): ResolutionDetails<boolean> {\n    return this.resolveAndCheckFlag<boolean>(flagKey, defaultValue, context || this._context, logger);\n  }\n\n  resolveNumberEvaluation(\n    flagKey: string,\n    defaultValue: number,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): ResolutionDetails<number> {\n    return this.resolveAndCheckFlag<number>(flagKey, defaultValue, context || this._context, logger);\n  }\n\n  resolveStringEvaluation(\n    flagKey: string,\n    defaultValue: string,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): ResolutionDetails<string> {\n    return this.resolveAndCheckFlag<string>(flagKey, defaultValue, context || this._context, logger);\n  }\n\n  resolveObjectEvaluation<T extends JsonValue>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): ResolutionDetails<T> {\n    return this.resolveAndCheckFlag<T>(flagKey, defaultValue, context || this._context, logger);\n  }\n\n  private resolveAndCheckFlag<T extends JsonValue | FlagValueType>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): ResolutionDetails<T> {\n    if (!(flagKey in this._flagConfiguration)) {\n      const message = `no flag found with key ${flagKey}`;\n      logger?.debug(message);\n      throw new FlagNotFoundError(message);\n    }\n\n    if (this._flagConfiguration[flagKey].disabled) {\n      return { value: defaultValue, reason: StandardResolutionReasons.DISABLED };\n    }\n\n    const resolvedFlag = this.resolveFlagWithReason(flagKey, context) as ResolutionDetails<T>;\n\n    if (resolvedFlag.value === undefined) {\n      const message = `no value associated with variant provided for ${flagKey} found`;\n      logger?.error(message);\n      throw new VariantNotFoundError(message);\n    }\n\n    if (typeof resolvedFlag.value != typeof defaultValue) {\n      throw new TypeMismatchError();\n    }\n\n    return resolvedFlag;\n  }\n\n  private resolveFlagWithReason<T extends JsonValue | FlagValueType>(\n    flagKey: string,\n    ctx?: EvaluationContext,\n  ): ResolutionDetails<T> {\n    try {\n      const resolutionResult = this.lookupFlagValue<T>(flagKey, ctx);\n\n      return resolutionResult;\n    } catch (error: unknown) {\n      if (!(error instanceof OpenFeatureError)) {\n        throw new GeneralError((error as Error)?.message || 'unknown error');\n      }\n      throw error;\n    }\n  }\n\n  private lookupFlagValue<T extends JsonValue | FlagValueType>(\n    flagKey: string,\n    ctx?: EvaluationContext,\n  ): ResolutionDetails<T> {\n    const flagSpec: Flag = this._flagConfiguration[flagKey];\n\n    const isContextEval = ctx && flagSpec?.contextEvaluator;\n    const variant = isContextEval ? flagSpec.contextEvaluator?.(ctx) : flagSpec.defaultVariant;\n\n    const value = variant && flagSpec?.variants[variant];\n\n    const reason = isContextEval ? StandardResolutionReasons.TARGETING_MATCH : StandardResolutionReasons.STATIC;\n\n    return {\n      value: value as T,\n      ...(variant && { variant }),\n      reason,\n    };\n  }\n}\n", "import { GenericEventEmitter } from '@openfeature/core';\nimport { EventEmitter } from 'eventemitter3';\nimport type { ProviderEmittableEvents } from './events';\n\n/**\n * The OpenFeatureEventEmitter can be used by provider developers to emit\n * events at various parts of the provider lifecycle.\n *\n * NOTE: Ready and error events are automatically emitted by the SDK based on\n * the result of the initialize method.\n */\nexport class OpenFeatureEventEmitter extends GenericEventEmitter<ProviderEmittableEvents> {\n  protected readonly eventEmitter = new EventEmitter();\n\n  constructor() {\n    super();\n  }\n}\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "import { ClientProviderEvents } from '@openfeature/core';\n\nexport { ClientProviderEvents as ProviderEvents};\n\n/**\n * A subset of events that can be directly emitted by providers.\n */\nexport type ProviderEmittableEvents = Exclude<ClientProviderEvents, ClientProviderEvents.ContextChanged>;", "import { ErrorCode, OpenFeatureError } from '@openfeature/core';\n\n/**\n * A custom error for the in-memory provider.\n * Indicates the resolved or default variant doesn't exist.\n */\nexport class VariantNotFoundError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, VariantNotFoundError.prototype);\n    this.name = 'VariantNotFoundError';\n    this.code = ErrorCode.GENERAL;\n  }\n}\n", "import type {\n  ClientProviderStatus,\n  EvaluationContext,\n  GenericEventEmitter,\n  ManageContext} from '@openfeature/core';\nimport {\n  OpenFeatureCommonAPI,\n  ProviderWrapper,\n  objectOrUndefined,\n  stringOrUndefined,\n} from '@openfeature/core';\nimport type { Client } from './client';\nimport { OpenFeatureClient } from './client/internal/open-feature-client';\nimport { OpenFeatureEventEmitter, ProviderEvents } from './events';\nimport type { Hook } from './hooks';\nimport type { Provider} from './provider';\nimport { NOOP_PROVIDER, ProviderStatus } from './provider';\n\n// use a symbol as a key for the global singleton\nconst GLOBAL_OPENFEATURE_API_KEY = Symbol.for('@openfeature/web-sdk/api');\n\ntype OpenFeatureGlobal = {\n  [GLOBAL_OPENFEATURE_API_KEY]?: OpenFeatureAPI;\n};\ntype DomainRecord = {\n  domain?: string;\n  wrapper: ProviderWrapper<Provider, ClientProviderStatus>;\n};\n\nconst _globalThis = globalThis as OpenFeatureGlobal;\n\nexport class OpenFeatureAPI\n  extends OpenFeatureCommonAPI<ClientProviderStatus, Provider, Hook>\n  implements ManageContext<Promise<void>>\n{\n  protected _statusEnumType: typeof ProviderStatus = ProviderStatus;\n  protected _apiEmitter: GenericEventEmitter<ProviderEvents> = new OpenFeatureEventEmitter();\n  protected _defaultProvider: ProviderWrapper<Provider, ClientProviderStatus> = new ProviderWrapper(\n    NOOP_PROVIDER,\n    ProviderStatus.NOT_READY,\n    this._statusEnumType,\n  );\n  protected _domainScopedProviders: Map<string, ProviderWrapper<Provider, ClientProviderStatus>> = new Map();\n  protected _createEventEmitter = () => new OpenFeatureEventEmitter();\n\n  private constructor() {\n    super('client');\n  }\n\n  /**\n   * Gets a singleton instance of the OpenFeature API.\n   * @ignore\n   * @returns {OpenFeatureAPI} OpenFeature API\n   */\n  static getInstance(): OpenFeatureAPI {\n    const globalApi = _globalThis[GLOBAL_OPENFEATURE_API_KEY];\n    if (globalApi) {\n      return globalApi;\n    }\n\n    const instance = new OpenFeatureAPI();\n    _globalThis[GLOBAL_OPENFEATURE_API_KEY] = instance;\n    return instance;\n  }\n\n  private getProviderStatus(domain?: string): ProviderStatus {\n    if (!domain) {\n      return this._defaultProvider.status;\n    }\n\n    return this._domainScopedProviders.get(domain)?.status ?? this._defaultProvider.status;\n  }\n\n  /**\n   * Sets the default provider for flag evaluations and returns a promise that resolves when the provider is ready.\n   * This provider will be used by domainless clients and clients associated with domains to which no provider is bound.\n   * Setting a provider supersedes the current provider used in new and existing unbound clients.\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @returns {Promise<void>}\n   * @throws Uncaught exceptions thrown by the provider during initialization.\n   */\n  setProviderAndWait(provider: Provider): Promise<void>;\n  /**\n   * Sets the default provider for flag evaluations and returns a promise that resolves when the provider is ready.\n   * This provider will be used by domainless clients and clients associated with domains to which no provider is bound.\n   * Setting a provider supersedes the current provider used in new and existing unbound clients.\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @param {EvaluationContext} context The evaluation context to use for flag evaluations.\n   * @returns {Promise<void>}\n   * @throws Uncaught exceptions thrown by the provider during initialization.\n   */\n  setProviderAndWait(provider: Provider, context: EvaluationContext): Promise<void>;\n  /**\n   * Sets the provider that OpenFeature will use for flag evaluations on clients bound to the same domain.\n   * A promise is returned that resolves when the provider is ready.\n   * Setting a provider supersedes the current provider used in new and existing clients bound to the same domain.\n   * @param {string} domain The name to identify the client\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @returns {Promise<void>}\n   * @throws Uncaught exceptions thrown by the provider during initialization.\n   */\n  setProviderAndWait(domain: string, provider: Provider): Promise<void>;\n  /**\n   * Sets the provider that OpenFeature will use for flag evaluations on clients bound to the same domain.\n   * A promise is returned that resolves when the provider is ready.\n   * Setting a provider supersedes the current provider used in new and existing clients bound to the same domain.\n   * @param {string} domain The name to identify the client\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @param {EvaluationContext} context The evaluation context to use for flag evaluations.\n   * @returns {Promise<void>}\n   * @throws Uncaught exceptions thrown by the provider during initialization.\n   */\n  setProviderAndWait(domain: string, provider: Provider, context: EvaluationContext): Promise<void>;\n  async setProviderAndWait(\n    clientOrProvider?: string | Provider,\n    providerContextOrUndefined?: Provider | EvaluationContext,\n    contextOrUndefined?: EvaluationContext,\n  ): Promise<void> {\n    const domain = stringOrUndefined(clientOrProvider);\n    const provider = domain\n      ? objectOrUndefined<Provider>(providerContextOrUndefined)\n      : objectOrUndefined<Provider>(clientOrProvider);\n    const context = domain\n      ? objectOrUndefined<EvaluationContext>(contextOrUndefined)\n      : objectOrUndefined<EvaluationContext>(providerContextOrUndefined);\n\n    if (context) {\n      // synonymously setting context prior to provider initialization.\n      // No context change event will be emitted.\n      if (domain) {\n        this._domainScopedContext.set(domain, context);\n      } else {\n        this._context = context;\n      }\n    }\n\n    await this.setAwaitableProvider(domain, provider);\n  }\n\n  /**\n   * Sets the default provider for flag evaluations.\n   * This provider will be used by domainless clients and clients associated with domains to which no provider is bound.\n   * Setting a provider supersedes the current provider used in new and existing unbound clients.\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @returns {this} OpenFeature API\n   */\n  setProvider(provider: Provider): this;\n  /**\n   * Sets the default provider and evaluation context for flag evaluations.\n   * This provider will be used by domainless clients and clients associated with domains to which no provider is bound.\n   * Setting a provider supersedes the current provider used in new and existing unbound clients.\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @param context {EvaluationContext} The evaluation context to use for flag evaluations.\n   * @returns {this} OpenFeature API\n   */\n  setProvider(provider: Provider, context: EvaluationContext): this;\n  /**\n   * Sets the provider for flag evaluations of providers with the given name.\n   * Setting a provider supersedes the current provider used in new and existing clients bound to the same domain.\n   * @param {string} domain The name to identify the client\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @returns {this} OpenFeature API\n   */\n  setProvider(domain: string, provider: Provider): this;\n  /**\n   * Sets the provider and evaluation context flag evaluations of providers with the given name.\n   * Setting a provider supersedes the current provider used in new and existing clients bound to the same domain.\n   * @param {string} domain The name to identify the client\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @param context {EvaluationContext} The evaluation context to use for flag evaluations.\n   * @returns {this} OpenFeature API\n   */\n  setProvider(domain: string, provider: Provider, context: EvaluationContext): this;\n  setProvider(\n    domainOrProvider?: string | Provider,\n    providerContextOrUndefined?: Provider | EvaluationContext,\n    contextOrUndefined?: EvaluationContext,\n  ): this {\n    const domain = stringOrUndefined(domainOrProvider);\n    const provider = domain\n      ? objectOrUndefined<Provider>(providerContextOrUndefined)\n      : objectOrUndefined<Provider>(domainOrProvider);\n    const context = domain\n      ? objectOrUndefined<EvaluationContext>(contextOrUndefined)\n      : objectOrUndefined<EvaluationContext>(providerContextOrUndefined);\n\n    if (context) {\n      // synonymously setting context prior to provider initialization.\n      // No context change event will be emitted.\n      if (domain) {\n        this._domainScopedContext.set(domain, context);\n      } else {\n        this._context = context;\n      }\n    }\n\n    const maybePromise = this.setAwaitableProvider(domain, provider);\n\n    // The setProvider method doesn't return a promise so we need to catch and\n    // log any errors that occur during provider initialization to avoid having\n    // an unhandled promise rejection.\n    Promise.resolve(maybePromise).catch((err) => {\n      this._logger.error('Error during provider initialization:', err);\n    });\n    return this;\n  }\n\n  /**\n   * Get the default provider.\n   *\n   * Note that it isn't recommended to interact with the provider directly, but rather through\n   * an OpenFeature client.\n   * @returns {Provider} Default Provider\n   */\n  getProvider(): Provider;\n  /**\n   * Get the provider bound to the specified domain.\n   *\n   * Note that it isn't recommended to interact with the provider directly, but rather through\n   * an OpenFeature client.\n   * @param {string} domain An identifier which logically binds clients with providers\n   * @returns {Provider} Domain-scoped provider\n   */\n  getProvider(domain?: string): Provider;\n  getProvider(domain?: string): Provider {\n    return this.getProviderForClient(domain);\n  }\n\n  /**\n   * Sets the evaluation context globally.\n   * This will be used by all providers that have not bound to a domain.\n   * @param {EvaluationContext} context Evaluation context\n   * @example\n   * await OpenFeature.setContext({ region: \"us\" });\n   */\n  async setContext(context: EvaluationContext): Promise<void>;\n  /**\n   * Sets the evaluation context for a specific provider.\n   * This will only affect providers bound to a domain.\n   * @param {string} domain An identifier which logically binds clients with providers\n   * @param {EvaluationContext} context Evaluation context\n   * @example\n   * await OpenFeature.setContext(\"test\", { scope: \"provider\" });\n   * OpenFeature.setProvider(new MyProvider()) // Uses the default context\n   * OpenFeature.setProvider(\"test\", new MyProvider()) // Uses context: { scope: \"provider\" }\n   */\n  async setContext(domain: string, context: EvaluationContext): Promise<void>;\n  async setContext<T extends EvaluationContext>(domainOrContext: T | string, contextOrUndefined?: T): Promise<void> {\n    const domain = stringOrUndefined(domainOrContext);\n    const context = objectOrUndefined<T>(domainOrContext) ?? objectOrUndefined(contextOrUndefined) ?? {};\n\n    if (domain) {\n      const wrapper = this._domainScopedProviders.get(domain);\n      if (wrapper) {\n        const oldContext = this.getContext(domain);\n        this._domainScopedContext.set(domain, context);\n        await this.runProviderContextChangeHandler(domain, wrapper, oldContext, context);\n      } else {\n        this._domainScopedContext.set(domain, context);\n      }\n    } else {\n      const oldContext = this._context;\n      this._context = context;\n\n      // collect all providers that are using the default context (not bound to a domain)\n      const unboundProviders: DomainRecord[] = Array.from(this._domainScopedProviders.entries())\n        .filter(([domain]) => !this._domainScopedContext.has(domain))\n        .reduce<DomainRecord[]>((acc, [domain, wrapper]) => {\n          acc.push({ domain, wrapper });\n          return acc;\n        }, []);\n\n      const allDomainRecords: DomainRecord[] = [\n        // add in the default (no domain)\n        { domain: undefined, wrapper: this._defaultProvider },\n        ...unboundProviders,\n      ];\n      await Promise.all(\n        allDomainRecords.map((dm) => this.runProviderContextChangeHandler(dm.domain, dm.wrapper, oldContext, context)),\n      );\n    }\n  }\n\n  /**\n   * Access the global evaluation context.\n   * @returns {EvaluationContext} Evaluation context\n   */\n  getContext(): EvaluationContext;\n  /**\n   * Access the evaluation context for a specific named client.\n   * The global evaluation context is returned if a matching named client is not found.\n   * @param {string} domain An identifier which logically binds clients with providers\n   * @returns {EvaluationContext} Evaluation context\n   */\n  getContext(domain?: string | undefined): EvaluationContext;\n  getContext(domainOrUndefined?: string): EvaluationContext {\n    const domain = stringOrUndefined(domainOrUndefined);\n    if (domain) {\n      const context = this._domainScopedContext.get(domain);\n      if (context) {\n        return context;\n      } else {\n        this._logger.debug(`Unable to find context for '${domain}'.`);\n      }\n    }\n    return this._context;\n  }\n\n  /**\n   * Resets the global evaluation context to an empty object.\n   */\n  clearContext(): Promise<void>;\n  /**\n   * Removes the evaluation context for a specific named client.\n   * @param {string} domain An identifier which logically binds clients with providers\n   */\n  clearContext(domain: string): Promise<void>;\n  async clearContext(domainOrUndefined?: string): Promise<void> {\n    const domain = stringOrUndefined(domainOrUndefined);\n    if (domain) {\n      const wrapper = this._domainScopedProviders.get(domain);\n      if (wrapper) {\n        const oldContext = this.getContext(domain);\n        this._domainScopedContext.delete(domain);\n        const newContext = this.getContext();\n        await this.runProviderContextChangeHandler(domain, wrapper, oldContext, newContext);\n      } else {\n        this._domainScopedContext.delete(domain);\n      }\n    } else {\n      return this.setContext({});\n    }\n  }\n\n  /**\n   * Resets the global evaluation context and removes the evaluation context for\n   * all domains.\n   */\n  async clearContexts(): Promise<void> {\n    // Default context must be cleared first to avoid calling the onContextChange\n    // handler multiple times for clients bound to a domain.\n    await this.clearContext();\n\n    // Use allSettled so a promise rejection doesn't affect others\n    await Promise.allSettled(Array.from(this._domainScopedProviders.keys()).map((domain) => this.clearContext(domain)));\n  }\n\n  /**\n   * A factory function for creating new domain-scoped OpenFeature clients. Clients\n   * can contain their own state (e.g. logger, hook, context). Multiple domains\n   * can be used to segment feature flag configuration.\n   *\n   * If there is already a provider bound to this name via {@link this.setProvider setProvider}, this provider will be used.\n   * Otherwise, the default provider is used until a provider is assigned to that name.\n   * @param {string} domain An identifier which logically binds clients with providers\n   * @param {string} version The version of the client (only used for metadata)\n   * @returns {Client} OpenFeature Client\n   */\n  getClient(domain?: string, version?: string): Client {\n    return new OpenFeatureClient(\n      // functions are passed here to make sure that these values are always up to date,\n      // and so we don't have to make these public properties on the API class.\n      () => this.getProviderForClient(domain),\n      () => this.getProviderStatus(domain),\n      () => this.buildAndCacheEventEmitterForClient(domain),\n      (domain?: string) => this.getContext(domain),\n      () => this.getHooks(),\n      () => this._logger,\n      { domain, version },\n    );\n  }\n\n  /**\n   * Clears all registered providers and resets the default provider.\n   * @returns {Promise<void>}\n   */\n  async clearProviders(): Promise<void> {\n    await super.clearProvidersAndSetDefault(NOOP_PROVIDER);\n    this._domainScopedContext.clear();\n  }\n\n  private async runProviderContextChangeHandler(\n    domain: string | undefined,\n    wrapper: ProviderWrapper<Provider, ClientProviderStatus>,\n    oldContext: EvaluationContext,\n    newContext: EvaluationContext,\n  ): Promise<void> {\n    // this should always be set according to the typings, but let's be defensive considering JS\n    const providerName = wrapper.provider?.metadata?.name || 'unnamed-provider';\n\n    try {\n      if (typeof wrapper.provider.onContextChange === 'function') {\n        const maybePromise = wrapper.provider.onContextChange(oldContext, newContext);\n\n        // only reconcile if the onContextChange method returns a promise\n        if (typeof maybePromise?.then === 'function') {\n          wrapper.incrementPendingContextChanges();\n          wrapper.status = this._statusEnumType.RECONCILING;\n          this.getAssociatedEventEmitters(domain).forEach((emitter) => {\n            emitter?.emit(ProviderEvents.Reconciling, { domain, providerName });\n          });\n          this._apiEmitter?.emit(ProviderEvents.Reconciling, { domain, providerName });\n\n          await maybePromise;\n          wrapper.decrementPendingContextChanges();\n        }\n      }\n      // only run the event handlers, and update the state if the onContextChange method succeeded\n      wrapper.status = this._statusEnumType.READY;\n      if (wrapper.allContextChangesSettled) {\n        this.getAssociatedEventEmitters(domain).forEach((emitter) => {\n          emitter?.emit(ProviderEvents.ContextChanged, { clientName: domain, domain, providerName });\n        });\n        this._apiEmitter?.emit(ProviderEvents.ContextChanged, { clientName: domain, domain, providerName });\n      }\n    } catch (err) {\n      // run error handlers instead\n      wrapper.decrementPendingContextChanges();\n      wrapper.status = this._statusEnumType.ERROR;\n      if (wrapper.allContextChangesSettled) {\n        const error = err as Error | undefined;\n        const message = `Error running ${providerName}'s context change handler: ${error?.message}`;\n        this._logger?.error(`${message}`, err);\n        this.getAssociatedEventEmitters(domain).forEach((emitter) => {\n          emitter?.emit(ProviderEvents.Error, { clientName: domain, domain, providerName, message });\n        });\n        this._apiEmitter?.emit(ProviderEvents.Error, { clientName: domain, domain, providerName, message });\n      }\n    }\n  }\n}\n\n/**\n * A singleton instance of the OpenFeature API.\n * @returns {OpenFeatureAPI} OpenFeature API\n */\nexport const OpenFeature = OpenFeatureAPI.getInstance();\n", "import type {\n  ClientMetadata,\n  EvaluationContext,\n  EvaluationDetails,\n  EventHandler,\n  FlagValue,\n  FlagValueType,\n  HookContext,\n  JsonValue,\n  Logger,\n  TrackingEventDetails,\n  OpenFeatureError,\n  FlagMetadata,\n  ResolutionDetails,\n  EventOptions,\n} from '@openfeature/core';\nimport {\n  ErrorCode,\n  ProviderFatalError,\n  ProviderNotReadyError,\n  SafeLogger,\n  StandardResolutionReasons,\n  instantiateErrorByErrorCode,\n  statusMatchesEvent,\n} from '@openfeature/core';\nimport type { FlagEvaluationOptions } from '../../evaluation';\nimport type { ProviderEvents } from '../../events';\nimport type { InternalEventEmitter } from '../../events/internal/internal-event-emitter';\nimport type { Hook } from '../../hooks';\nimport type { Provider } from '../../provider';\nimport { ProviderStatus } from '../../provider';\nimport type { Client } from './../client';\n\ntype OpenFeatureClientOptions = {\n  /**\n   * @deprecated Use `domain` instead.\n   */\n  name?: string;\n  domain?: string;\n  version?: string;\n};\n\n/**\n * This implementation of the {@link Client} is meant to only be instantiated by the SDK.\n * It should not be used outside the SDK and so should not be exported.\n * @internal\n */\nexport class OpenFeatureClient implements Client {\n  private _hooks: Hook[] = [];\n  private _clientLogger?: Logger;\n\n  constructor(\n    // functions are passed here to make sure that these values are always up to date,\n    // and so we don't have to make these public properties on the API class.\n    private readonly providerAccessor: () => Provider,\n    private readonly providerStatusAccessor: () => ProviderStatus,\n    private readonly emitterAccessor: () => InternalEventEmitter,\n    private readonly apiContextAccessor: (domain?: string) => EvaluationContext,\n    private readonly apiHooksAccessor: () => Hook[],\n    private readonly globalLogger: () => Logger,\n    private readonly options: OpenFeatureClientOptions,\n  ) {}\n\n  get metadata(): ClientMetadata {\n    return {\n      // Use domain if name is not provided\n      name: this.options.domain ?? this.options.name,\n      domain: this.options.domain ?? this.options.name,\n      version: this.options.version,\n      providerMetadata: this.providerAccessor().metadata,\n    };\n  }\n\n  get providerStatus(): ProviderStatus {\n    return this.providerStatusAccessor();\n  }\n\n  addHandler(eventType: ProviderEvents, handler: EventHandler, options: EventOptions): void {\n    this.emitterAccessor().addHandler(eventType, handler);\n    const shouldRunNow = statusMatchesEvent(eventType, this.providerStatus);\n\n    if (shouldRunNow) {\n      // run immediately, we're in the matching state\n      try {\n        handler({\n          clientName: this.metadata.name,\n          domain: this.metadata.domain,\n          providerName: this._provider.metadata.name,\n        });\n      } catch (err) {\n        this._logger?.error('Error running event handler:', err);\n      }\n    }\n\n    if (options?.signal && typeof options.signal.addEventListener === 'function') {\n      options.signal.addEventListener('abort', () => {\n        this.removeHandler(eventType, handler);\n      });\n    }\n  }\n\n  removeHandler(notificationType: ProviderEvents, handler: EventHandler): void {\n    this.emitterAccessor().removeHandler(notificationType, handler);\n  }\n\n  getHandlers(eventType: ProviderEvents) {\n    return this.emitterAccessor().getHandlers(eventType);\n  }\n\n  setLogger(logger: Logger): this {\n    this._clientLogger = new SafeLogger(logger);\n    return this;\n  }\n\n  addHooks(...hooks: Hook[]): this {\n    this._hooks = [...this._hooks, ...hooks];\n    return this;\n  }\n\n  getHooks(): Hook[] {\n    return this._hooks;\n  }\n\n  clearHooks(): this {\n    this._hooks = [];\n    return this;\n  }\n\n  getBooleanValue(flagKey: string, defaultValue: boolean, options?: FlagEvaluationOptions): boolean {\n    return this.getBooleanDetails(flagKey, defaultValue, options).value;\n  }\n\n  getBooleanDetails(\n    flagKey: string,\n    defaultValue: boolean,\n    options?: FlagEvaluationOptions,\n  ): EvaluationDetails<boolean> {\n    return this.evaluate<boolean>(flagKey, this._provider.resolveBooleanEvaluation, defaultValue, 'boolean', options);\n  }\n\n  getStringValue<T extends string = string>(flagKey: string, defaultValue: T, options?: FlagEvaluationOptions): T {\n    return this.getStringDetails<T>(flagKey, defaultValue, options).value;\n  }\n\n  getStringDetails<T extends string = string>(\n    flagKey: string,\n    defaultValue: T,\n    options?: FlagEvaluationOptions,\n  ): EvaluationDetails<T> {\n    return this.evaluate<T>(\n      flagKey,\n      // this isolates providers from our restricted string generic argument.\n      this._provider.resolveStringEvaluation as () => EvaluationDetails<T>,\n      defaultValue,\n      'string',\n      options,\n    );\n  }\n\n  getNumberValue<T extends number = number>(flagKey: string, defaultValue: T, options?: FlagEvaluationOptions): T {\n    return this.getNumberDetails(flagKey, defaultValue, options).value;\n  }\n\n  getNumberDetails<T extends number = number>(\n    flagKey: string,\n    defaultValue: T,\n    options?: FlagEvaluationOptions,\n  ): EvaluationDetails<T> {\n    return this.evaluate<T>(\n      flagKey,\n      // this isolates providers from our restricted number generic argument.\n      this._provider.resolveNumberEvaluation as () => EvaluationDetails<T>,\n      defaultValue,\n      'number',\n      options,\n    );\n  }\n\n  getObjectValue<T extends JsonValue = JsonValue>(\n    flagKey: string,\n    defaultValue: T,\n    options?: FlagEvaluationOptions,\n  ): T {\n    return this.getObjectDetails(flagKey, defaultValue, options).value;\n  }\n\n  getObjectDetails<T extends JsonValue = JsonValue>(\n    flagKey: string,\n    defaultValue: T,\n    options?: FlagEvaluationOptions,\n  ): EvaluationDetails<T> {\n    return this.evaluate<T>(flagKey, this._provider.resolveObjectEvaluation, defaultValue, 'object', options);\n  }\n\n  track(occurrenceKey: string, occurrenceDetails: TrackingEventDetails = {}): void {\n    try {\n      this.shortCircuitIfNotReady();\n\n      if (typeof this._provider.track === 'function') {\n        // copy and freeze the context\n        const frozenContext = Object.freeze({\n          ...this.apiContextAccessor(this?.options?.domain),\n        });\n        return this._provider.track?.(occurrenceKey, frozenContext, occurrenceDetails);\n      } else {\n        this._logger.debug('Provider does not support the track function; will no-op.');\n      }\n    } catch (err) {\n      this._logger.debug('Error recording tracking event.', err);\n    }\n  }\n\n  private evaluate<T extends FlagValue>(\n    flagKey: string,\n    resolver: (flagKey: string, defaultValue: T, context: EvaluationContext, logger: Logger) => ResolutionDetails<T>,\n    defaultValue: T,\n    flagType: FlagValueType,\n    options: FlagEvaluationOptions = {},\n  ): EvaluationDetails<T> {\n    // merge global, client, and evaluation context\n\n    const allHooks = [\n      ...this.apiHooksAccessor(),\n      ...this.getHooks(),\n      ...(options.hooks || []),\n      ...(this._provider.hooks || []),\n    ];\n    const allHooksReversed = [...allHooks].reverse();\n\n    const context = {\n      ...this.apiContextAccessor(this?.options?.domain),\n    };\n\n    // this reference cannot change during the course of evaluation\n    // it may be used as a key in WeakMaps\n    const hookContext: Readonly<HookContext> = {\n      flagKey,\n      defaultValue,\n      flagValueType: flagType,\n      clientMetadata: this.metadata,\n      providerMetadata: this._provider.metadata,\n      context,\n      logger: this._logger,\n    };\n\n    let evaluationDetails: EvaluationDetails<T>;\n\n    try {\n      this.beforeHooks(allHooks, hookContext, options);\n\n      this.shortCircuitIfNotReady();\n\n      // run the referenced resolver, binding the provider.\n      const resolution = resolver.call(this._provider, flagKey, defaultValue, context, this._logger);\n\n      const resolutionDetails = {\n        ...resolution,\n        flagMetadata: Object.freeze(resolution.flagMetadata ?? {}),\n        flagKey,\n      };\n\n      if (resolutionDetails.errorCode) {\n        const err = instantiateErrorByErrorCode(resolutionDetails.errorCode, resolutionDetails.errorMessage);\n        this.errorHooks(allHooksReversed, hookContext, err, options);\n        evaluationDetails = this.getErrorEvaluationDetails(flagKey, defaultValue, err, resolutionDetails.flagMetadata);\n      } else {\n        this.afterHooks(allHooksReversed, hookContext, resolutionDetails, options);\n        evaluationDetails = resolutionDetails;\n      }\n    } catch (err: unknown) {\n      this.errorHooks(allHooksReversed, hookContext, err, options);\n      evaluationDetails = this.getErrorEvaluationDetails(flagKey, defaultValue, err);\n    }\n    this.finallyHooks(allHooksReversed, hookContext, evaluationDetails, options);\n    return evaluationDetails;\n  }\n\n  private beforeHooks(hooks: Hook[], hookContext: HookContext, options: FlagEvaluationOptions) {\n    Object.freeze(hookContext);\n    Object.freeze(hookContext.context);\n\n    for (const hook of hooks) {\n      hook?.before?.(hookContext, Object.freeze(options.hookHints));\n    }\n  }\n\n  private afterHooks(\n    hooks: Hook[],\n    hookContext: HookContext,\n    evaluationDetails: EvaluationDetails<FlagValue>,\n    options: FlagEvaluationOptions,\n  ) {\n    // run \"after\" hooks sequentially\n    for (const hook of hooks) {\n      hook?.after?.(hookContext, evaluationDetails, options.hookHints);\n    }\n  }\n\n  private errorHooks(hooks: Hook[], hookContext: HookContext, err: unknown, options: FlagEvaluationOptions) {\n    // run \"error\" hooks sequentially\n    for (const hook of hooks) {\n      try {\n        hook?.error?.(hookContext, err, options.hookHints);\n      } catch (err) {\n        this._logger.error(`Unhandled error during 'error' hook: ${err}`);\n        if (err instanceof Error) {\n          this._logger.error(err.stack);\n        }\n        this._logger.error((err as Error)?.stack);\n      }\n    }\n  }\n\n  private finallyHooks(\n    hooks: Hook[],\n    hookContext: HookContext,\n    evaluationDetails: EvaluationDetails<FlagValue>,\n    options: FlagEvaluationOptions,\n  ) {\n    // run \"finally\" hooks sequentially\n    for (const hook of hooks) {\n      try {\n        hook?.finally?.(hookContext, evaluationDetails, options.hookHints);\n      } catch (err) {\n        this._logger.error(`Unhandled error during 'finally' hook: ${err}`);\n        if (err instanceof Error) {\n          this._logger.error(err.stack);\n        }\n        this._logger.error((err as Error)?.stack);\n      }\n    }\n  }\n\n  private get _provider(): Provider {\n    return this.providerAccessor();\n  }\n\n  private get _logger() {\n    return this._clientLogger || this.globalLogger();\n  }\n\n  private shortCircuitIfNotReady() {\n    // short circuit evaluation entirely if provider is in a bad state\n    if (this.providerStatus === ProviderStatus.NOT_READY) {\n      throw new ProviderNotReadyError('provider has not yet initialized');\n    } else if (this.providerStatus === ProviderStatus.FATAL) {\n      throw new ProviderFatalError('provider is in an irrecoverable error state');\n    }\n  }\n\n  private getErrorEvaluationDetails<T extends FlagValue>(\n    flagKey: string,\n    defaultValue: T,\n    err: unknown,\n    flagMetadata: FlagMetadata = {},\n  ): EvaluationDetails<T> {\n    const errorMessage: string = (err as Error)?.message;\n    const errorCode: ErrorCode = (err as OpenFeatureError)?.code || ErrorCode.GENERAL;\n\n    return {\n      errorCode,\n      errorMessage,\n      value: defaultValue,\n      reason: StandardResolutionReasons.ERROR,\n      flagMetadata: Object.freeze(flagMetadata),\n      flagKey,\n    };\n  }\n}\n", "export * from './client';\nexport * from './provider';\nexport * from './evaluation';\nexport * from './open-feature';\nexport * from './events';\nexport * from './hooks';\nexport * from './tracking';\nexport * from '@openfeature/core';\n"],
  "mappings": "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",
  "names": ["EventEmitter", "OpenFeatureError", "EventEmitter", "OpenFeatureError", "ErrorCode", "StandardResolutionReasons", "err", "ErrorCode", "StandardResolutionReasons", "domain"]
}
