"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var index_exports = {};
__export(index_exports, {
  OpenFeatureProvider: () => OpenFeatureProvider,
  OpenFeatureTestProvider: () => OpenFeatureTestProvider,
  useBooleanFlagDetails: () => useBooleanFlagDetails,
  useBooleanFlagValue: () => useBooleanFlagValue,
  useContextMutator: () => useContextMutator,
  useFlag: () => useFlag,
  useNumberFlagDetails: () => useNumberFlagDetails,
  useNumberFlagValue: () => useNumberFlagValue,
  useObjectFlagDetails: () => useObjectFlagDetails,
  useObjectFlagValue: () => useObjectFlagValue,
  useOpenFeatureClient: () => useOpenFeatureClient,
  useOpenFeatureClientStatus: () => useOpenFeatureClientStatus,
  useStringFlagDetails: () => useStringFlagDetails,
  useStringFlagValue: () => useStringFlagValue,
  useSuspenseFlag: () => useSuspenseFlag,
  useTrack: () => useTrack,
  useWhenProviderReady: () => useWhenProviderReady
});
module.exports = __toCommonJS(index_exports);

// src/evaluation/use-feature-flag.ts
var import_web_sdk5 = require("@openfeature/web-sdk");
var import_react6 = require("react");

// src/internal/context.ts
var import_react = __toESM(require("react"));
var Context = import_react.default.createContext(void 0);
function useProviderOptions() {
  const { options } = import_react.default.useContext(Context) || {};
  return normalizeOptions(options);
}

// src/internal/is-equal.ts
function isEqual(value, other) {
  if (value === other) {
    return true;
  }
  if (typeof value !== typeof other) {
    return false;
  }
  if (typeof value === "object" && value !== null && other !== null) {
    const valueKeys = Object.keys(value);
    const otherKeys = Object.keys(other);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    for (const key of valueKeys) {
      if (!isEqual(value[key], other[key])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// src/internal/options.ts
var DEFAULT_OPTIONS = {
  updateOnContextChanged: true,
  updateOnConfigurationChanged: true,
  suspendUntilReady: false,
  suspendWhileReconciling: false
};
var normalizeOptions = (options = {}) => {
  const updateOnContextChanged = options.updateOnContextChanged;
  const updateOnConfigurationChanged = options.updateOnConfigurationChanged;
  const suspendUntilReady = "suspendUntilReady" in options ? options.suspendUntilReady : options.suspend;
  const suspendWhileReconciling = "suspendWhileReconciling" in options ? options.suspendWhileReconciling : options.suspend;
  return __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, typeof suspendUntilReady === "boolean" && { suspendUntilReady }), typeof suspendWhileReconciling === "boolean" && { suspendWhileReconciling }), typeof updateOnContextChanged === "boolean" && { updateOnContextChanged }), typeof updateOnConfigurationChanged === "boolean" && { updateOnConfigurationChanged });
};

// src/internal/suspense.ts
var import_web_sdk = require("@openfeature/web-sdk");

// src/internal/use.ts
var import_react2 = __toESM(require("react"));
var use = import_react2.default.use || // This extra generic is to avoid TypeScript mixing up the generic and JSX syntax
// and emitting an error.
// We assume that this is only for the `use(thenable)` case, not `use(context)`.
// https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45
// eslint-disable-next-line @typescript-eslint/no-unused-vars
((thenable) => {
  switch (thenable.status) {
    case "pending":
      throw thenable;
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      thenable.status = "pending";
      thenable.then(
        (v) => {
          thenable.status = "fulfilled";
          thenable.value = v;
        },
        (e) => {
          thenable.status = "rejected";
          thenable.reason = e;
        }
      );
      throw thenable;
  }
});

// src/internal/suspense.ts
var globalProviderSuspenseStatus = /* @__PURE__ */ new WeakMap();
function suspendUntilInitialized(provider, client) {
  const statusPromiseRef = globalProviderSuspenseStatus.get(provider);
  if (!statusPromiseRef) {
    const statusPromise = provider !== import_web_sdk.NOOP_PROVIDER ? isProviderReady(client) : Promise.resolve();
    globalProviderSuspenseStatus.set(provider, statusPromise);
    use(statusPromise);
  } else {
    use(statusPromiseRef);
  }
}
function suspendUntilReconciled(client) {
  use(isProviderReady(client));
}
function isProviderReady(client) {
  return __async(this, null, function* () {
    const controller = new AbortController();
    try {
      return yield new Promise((resolve, reject) => {
        client.addHandler(import_web_sdk.ProviderEvents.Ready, resolve, { signal: controller.signal });
        client.addHandler(import_web_sdk.ProviderEvents.Error, reject, { signal: controller.signal });
      });
    } finally {
      controller.abort();
    }
  });
}

// src/provider/use-open-feature-client.ts
var import_react3 = __toESM(require("react"));

// src/internal/errors.ts
var context = "Components using OpenFeature must be wrapped with an <OpenFeatureProvider>.";
var tip = "If you are seeing this in a test, see: https://openfeature.dev/docs/reference/technologies/client/web/react#testing";
var MissingContextError = class extends Error {
  constructor(reason) {
    super(`${reason}: ${context} ${tip}`);
    this.name = "MissingContextError";
  }
};

// src/provider/use-open-feature-client.ts
function useOpenFeatureClient() {
  const { client } = import_react3.default.useContext(Context) || {};
  if (!client) {
    throw new MissingContextError("No OpenFeature client available");
  }
  return client;
}

// src/provider/use-open-feature-client-status.ts
var import_react4 = require("react");
var import_web_sdk2 = require("@openfeature/web-sdk");
function useOpenFeatureClientStatus() {
  const client = useOpenFeatureClient();
  const [status, setStatus] = (0, import_react4.useState)(client.providerStatus);
  const controller = new AbortController();
  (0, import_react4.useEffect)(() => {
    const updateStatus = () => setStatus(client.providerStatus);
    client.addHandler(import_web_sdk2.ProviderEvents.ConfigurationChanged, updateStatus, { signal: controller.signal });
    client.addHandler(import_web_sdk2.ProviderEvents.ContextChanged, updateStatus, { signal: controller.signal });
    client.addHandler(import_web_sdk2.ProviderEvents.Error, updateStatus, { signal: controller.signal });
    client.addHandler(import_web_sdk2.ProviderEvents.Ready, updateStatus, { signal: controller.signal });
    client.addHandler(import_web_sdk2.ProviderEvents.Stale, updateStatus, { signal: controller.signal });
    client.addHandler(import_web_sdk2.ProviderEvents.Reconciling, updateStatus, { signal: controller.signal });
    return () => {
      controller.abort();
    };
  }, [client]);
  return status;
}

// src/provider/use-open-feature-provider.ts
var import_react5 = __toESM(require("react"));
var import_web_sdk3 = require("@openfeature/web-sdk");
function useOpenFeatureProvider() {
  const openFeatureContext = import_react5.default.useContext(Context);
  if (!openFeatureContext) {
    throw new MissingContextError("No OpenFeature context available");
  }
  return import_web_sdk3.OpenFeature.getProvider(openFeatureContext.domain);
}

// src/internal/hook-flag-query.ts
var import_web_sdk4 = require("@openfeature/web-sdk");
var HookFlagQuery = class {
  constructor(_details) {
    this._details = _details;
  }
  get details() {
    return this._details;
  }
  get value() {
    var _a;
    return (_a = this._details) == null ? void 0 : _a.value;
  }
  get variant() {
    return this._details.variant;
  }
  get flagMetadata() {
    return this._details.flagMetadata;
  }
  get reason() {
    return this._details.reason;
  }
  get isError() {
    var _a;
    return !!((_a = this._details) == null ? void 0 : _a.errorCode) || this._details.reason == import_web_sdk4.StandardResolutionReasons.ERROR;
  }
  get errorCode() {
    var _a;
    return (_a = this._details) == null ? void 0 : _a.errorCode;
  }
  get errorMessage() {
    var _a;
    return (_a = this._details) == null ? void 0 : _a.errorMessage;
  }
  get isAuthoritative() {
    return !this.isError && this._details.reason != import_web_sdk4.StandardResolutionReasons.STALE && this._details.reason != import_web_sdk4.StandardResolutionReasons.DISABLED;
  }
  get type() {
    return typeof this._details.value;
  }
};

// src/evaluation/use-feature-flag.ts
function useFlag(flagKey, defaultValue, options) {
  const query = typeof defaultValue === "boolean" ? new HookFlagQuery(useBooleanFlagDetails(flagKey, defaultValue, options)) : typeof defaultValue === "number" ? new HookFlagQuery(useNumberFlagDetails(flagKey, defaultValue, options)) : typeof defaultValue === "string" ? new HookFlagQuery(useStringFlagDetails(flagKey, defaultValue, options)) : new HookFlagQuery(useObjectFlagDetails(flagKey, defaultValue, options));
  return query;
}
function useSuspenseFlag(flagKey, defaultValue, options) {
  return useFlag(flagKey, defaultValue, __spreadProps(__spreadValues({}, options), { suspendUntilReady: true, suspendWhileReconciling: true }));
}
function useBooleanFlagValue(flagKey, defaultValue, options) {
  return useBooleanFlagDetails(flagKey, defaultValue, options).value;
}
function useBooleanFlagDetails(flagKey, defaultValue, options) {
  return attachHandlersAndResolve(
    flagKey,
    defaultValue,
    (client) => {
      return client.getBooleanDetails;
    },
    options
  );
}
function useStringFlagValue(flagKey, defaultValue, options) {
  return useStringFlagDetails(flagKey, defaultValue, options).value;
}
function useStringFlagDetails(flagKey, defaultValue, options) {
  return attachHandlersAndResolve(
    flagKey,
    defaultValue,
    (client) => {
      return client.getStringDetails;
    },
    options
  );
}
function useNumberFlagValue(flagKey, defaultValue, options) {
  return useNumberFlagDetails(flagKey, defaultValue, options).value;
}
function useNumberFlagDetails(flagKey, defaultValue, options) {
  return attachHandlersAndResolve(
    flagKey,
    defaultValue,
    (client) => {
      return client.getNumberDetails;
    },
    options
  );
}
function useObjectFlagValue(flagKey, defaultValue, options) {
  return useObjectFlagDetails(flagKey, defaultValue, options).value;
}
function useObjectFlagDetails(flagKey, defaultValue, options) {
  return attachHandlersAndResolve(
    flagKey,
    defaultValue,
    (client) => {
      return client.getObjectDetails;
    },
    options
  );
}
function shouldEvaluateFlag(flagKey, flagsChanged) {
  return !flagsChanged || flagsChanged.includes(flagKey);
}
function attachHandlersAndResolve(flagKey, defaultValue, resolver, options) {
  const defaultedOptions = __spreadValues(__spreadValues(__spreadValues({}, DEFAULT_OPTIONS), useProviderOptions()), normalizeOptions(options));
  const client = useOpenFeatureClient();
  const status = useOpenFeatureClientStatus();
  const provider = useOpenFeatureProvider();
  const controller = new AbortController();
  if (defaultedOptions.suspendUntilReady && status === import_web_sdk5.ProviderStatus.NOT_READY) {
    suspendUntilInitialized(provider, client);
  }
  if (defaultedOptions.suspendWhileReconciling && status === import_web_sdk5.ProviderStatus.RECONCILING) {
    suspendUntilReconciled(client);
  }
  const [evaluationDetails, setEvaluationDetails] = (0, import_react6.useState)(
    resolver(client).call(client, flagKey, defaultValue, options)
  );
  const evaluationDetailsRef = (0, import_react6.useRef)(evaluationDetails);
  (0, import_react6.useEffect)(() => {
    evaluationDetailsRef.current = evaluationDetails;
  }, [evaluationDetails]);
  const updateEvaluationDetailsCallback = () => {
    const updatedEvaluationDetails = resolver(client).call(client, flagKey, defaultValue, options);
    if (!isEqual(updatedEvaluationDetails.value, evaluationDetailsRef.current.value)) {
      setEvaluationDetails(updatedEvaluationDetails);
    }
  };
  const configurationChangeCallback = (eventDetails) => {
    if (shouldEvaluateFlag(flagKey, eventDetails == null ? void 0 : eventDetails.flagsChanged)) {
      updateEvaluationDetailsCallback();
    }
  };
  (0, import_react6.useEffect)(() => {
    if (status === import_web_sdk5.ProviderStatus.NOT_READY) {
      client.addHandler(import_web_sdk5.ProviderEvents.Ready, updateEvaluationDetailsCallback, { signal: controller.signal });
    }
    if (defaultedOptions.updateOnContextChanged) {
      client.addHandler(import_web_sdk5.ProviderEvents.ContextChanged, updateEvaluationDetailsCallback, { signal: controller.signal });
    }
    if (defaultedOptions.updateOnConfigurationChanged) {
      client.addHandler(import_web_sdk5.ProviderEvents.ConfigurationChanged, configurationChangeCallback, {
        signal: controller.signal
      });
    }
    return () => {
      controller.abort();
    };
  }, []);
  return evaluationDetails;
}

// src/provider/provider.tsx
var import_web_sdk6 = require("@openfeature/web-sdk");
var React5 = __toESM(require("react"));
function OpenFeatureProvider(_a) {
  var _b = _a, { client, domain, children } = _b, options = __objRest(_b, ["client", "domain", "children"]);
  if (!client) {
    client = import_web_sdk6.OpenFeature.getClient(domain);
  }
  return /* @__PURE__ */ React5.createElement(Context.Provider, { value: { client, options, domain } }, children);
}

// src/provider/use-when-provider-ready.ts
var import_web_sdk7 = require("@openfeature/web-sdk");
function useWhenProviderReady(options) {
  const defaultedOptions = __spreadValues(__spreadValues(__spreadValues({}, DEFAULT_OPTIONS), useProviderOptions()), normalizeOptions(options));
  const client = useOpenFeatureClient();
  const status = useOpenFeatureClientStatus();
  const provider = useOpenFeatureProvider();
  if (defaultedOptions.suspendUntilReady && status === import_web_sdk7.ProviderStatus.NOT_READY) {
    suspendUntilInitialized(provider, client);
  }
  return status === import_web_sdk7.ProviderStatus.READY;
}

// src/provider/test-provider.tsx
var import_web_sdk8 = require("@openfeature/web-sdk");
var import_react7 = __toESM(require("react"));
var TEST_VARIANT = "test-variant";
var TEST_PROVIDER = "test-provider";
var TestProvider = class extends import_web_sdk8.InMemoryProvider {
  constructor(flagValueMap, delay = 0) {
    const flagConfig = Object.entries(flagValueMap).reduce((acc, flag) => {
      return __spreadProps(__spreadValues({}, acc), {
        [flag[0]]: {
          variants: {
            [TEST_VARIANT]: flag[1]
          },
          defaultVariant: TEST_VARIANT,
          disabled: false
        }
      });
    }, {});
    super(flagConfig);
    this.delay = delay;
    // initially make this undefined, we still set it if a delay is specified
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore - For maximum compatibility with previous versions, we ignore a possible TS error here,
    // since "initialize" was previously defined in superclass.
    // We can safely remove this ts-ignore in a few versions
    this.initialize = void 0;
    // "place-holder" init function which we only assign if want a delay
    this.delayedInitialize = () => __async(this, null, function* () {
      yield new Promise((resolve) => setTimeout(resolve, this.delay));
    });
    this.initialize = this.delay ? this.delayedInitialize.bind(this) : void 0;
  }
  onContextChange() {
    return __async(this, null, function* () {
      return new Promise((resolve) => setTimeout(resolve, this.delay));
    });
  }
};
function OpenFeatureTestProvider(testProviderOptions) {
  const { flagValueMap, provider } = testProviderOptions;
  const effectiveProvider = flagValueMap ? new TestProvider(flagValueMap, testProviderOptions.delayMs) : mixInNoop(provider) || import_web_sdk8.NOOP_PROVIDER;
  testProviderOptions.domain ? import_web_sdk8.OpenFeature.setProvider(testProviderOptions.domain, effectiveProvider) : import_web_sdk8.OpenFeature.setProvider(effectiveProvider);
  return /* @__PURE__ */ import_react7.default.createElement(OpenFeatureProvider, __spreadProps(__spreadValues({}, testProviderOptions), { domain: testProviderOptions.domain }), testProviderOptions.children);
}
function mixInNoop(provider = {}) {
  for (const prop of Object.getOwnPropertyNames(Object.getPrototypeOf(import_web_sdk8.NOOP_PROVIDER)).filter((prop2) => prop2 !== "constructor")) {
    const patchedProvider = provider;
    if (!Object.getPrototypeOf(patchedProvider)[prop] && !patchedProvider[prop]) {
      patchedProvider[prop] = Object.getPrototypeOf(import_web_sdk8.NOOP_PROVIDER)[prop];
    }
  }
  if (!provider.metadata || !provider.metadata.name) {
    provider.metadata = { name: TEST_PROVIDER };
  }
  return provider;
}

// src/context/use-context-mutator.ts
var import_react8 = require("react");
var import_web_sdk9 = require("@openfeature/web-sdk");
function useContextMutator(options = { defaultContext: false }) {
  const { domain } = (0, import_react8.useContext)(Context) || {};
  const previousContext = (0, import_react8.useRef)(null);
  const setContext = (0, import_react8.useCallback)((updatedContext) => __async(this, null, function* () {
    if (previousContext.current !== updatedContext) {
      if (!domain || (options == null ? void 0 : options.defaultContext)) {
        import_web_sdk9.OpenFeature.setContext(updatedContext);
      } else {
        import_web_sdk9.OpenFeature.setContext(domain, updatedContext);
      }
      previousContext.current = updatedContext;
    }
  }), [domain]);
  return {
    setContext
  };
}

// src/tracking/use-track.ts
var import_react9 = require("react");
function useTrack() {
  const client = useOpenFeatureClient();
  const track = (0, import_react9.useCallback)((trackingEventName, trackingEventDetails) => {
    client.track(trackingEventName, trackingEventDetails);
  }, []);
  return {
    track
  };
}

// src/index.ts
__reExport(index_exports, require("@openfeature/web-sdk"), module.exports);
//# sourceMappingURL=index.js.map
